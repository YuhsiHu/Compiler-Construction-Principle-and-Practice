# 编译原理复习提纲

## 目录
---------
### 1. [编译器工作过程](#1)
### 2. [词法分析](#2)
### 3. [上下文无关法](#3)
### 4. [语法分析](#4)
### 5. [语义分析](#5)
### 6. [中间代码生成](#6)  
### 7. [运行时环境](#7)
   
## 1.编译器工作过程（非考点）
<span id="1"></span>
--------------------
### 1.1 编译器（compiler）的发展  
* **第一代编程语言**：20世纪40年代，冯•诺伊曼存储—程序计算机，编写一串代码或程序成为必要，开始用机器语言编写程序。
* **第二代编程语言**：汇编语言。汇编程序将汇编语言程序的符号代码和存储地址翻译成与之等价的机器码。  
* **第三代编程语言**：高级语言。类似于数学定义或自然语言的简洁形式来编写程序，与机器无关。 
 
**编译器的定义**：把计算机高级语言(源语言)编写的程序(源程序)翻译成该计算机的汇编语言或机器语言(目标语言)书写的程序(目标程序)的计算机程序称为编译器(或编译程序)。   

### 1.2 解释程序（interpreter）  
解释程序是如同编译器的一种语言翻译程序，与编译器不同之处在于：
* 它以源程序为输入，在执行过程中不产生目标程序（代码），而是边解释边执行，即直接执行源程序中蕴含的操作。
* 解释程序实现简单，易于在解释执行过程中插入修改和调试措施，但边解释边执行的方式工作效率低，可能需要重复翻译和执行语句，它经常用于执行命令语言(Python)和交互式会话语言程序的执行等。
* 编译执行和解释执行是两种最基本的运行程序的途径。
  
### 1.3 编译器构造逻辑阶段的划分
![编译器逻辑结构](/storage/编译器构造逻辑阶段划分.png)  

* **词法分析程序**：逐个读入源程序字符并按照构词规则切分成一系列单词(token)。单词是语言中具有独立意义的最小单位，包括保留字、标识符、运算符、标点符号和常量等。
* **语法分析程序**：语法分析以词法分析程序输出的单词序列(或流)为输入，分析源程序的语法结构，判断它是否为相应程序设计语言的合法程序，并可以确定单词流中违反源语言语法结构规则的错误。
* **语义分析程序**：语义分析是在语法分析程序确定出语法短语后，审查有无语义错误，并为代码生成阶段收集符号属性信息。
* **中间代码生成**：为了处理方便和便于代码优化，通常在语义分析后并不直接产生目标代码，而是生成介于源代码和目标代码二者之间的中间代码。
* **代码优化程序**：代码优化工作可以在不同的编译阶段进行，其中对中间代码的优化尤其重要。为了使生成的目标代码更为高效，可以对产生的中间代码进行等价变换或改造（称为代码的优化）。
* **目标代码生成**：将中间代码翻译成为目标程序。通常目标代码可采用如下三种形式之一：
   * 具有绝对地址的机器指令代码。
   * 模块结构的机器指令。
   * 汇编语言形式的目标程序。
* **常数表**：常数表的功能是存放在编译过程中用到的常量和字符串，快速插入和查找操作在常数表中十分重要。由于常数表的数据在整个编译过程中都被用到，所以无需在常数表中进行删除操作。
* **符号表**：符号表存储函数、变量、常量以及数据类型等标识符相关的信息。符号表用于以下情况：
  * 在词法分析、语法分析和语义分析的过程中收集有关标识符的属性，并存于符号表中。
  * 作为进行语法和语义的合法性检查的依据。例如，同一个标识符可能在程序的不同地方出现，需要检查标识符在上下文中的一致性和合法性，而符号表正是进行这种检查的依据；
* **错误处理器**：在编译的每一个阶段，编译器对源程序中错误的反应是其重要功能之一。
  
### 1.4 编译阶段的组合——前端与后端
* **前端（Front-End）**：与目标机无关的部分。包括分析部分(词法、语法、语义分析)、中间代码生成与优化以及这部分的符号表管理错误处理。
*  **后端（Back-End）**：与目标机有关部分。包括目标代码生成、与目标机有关的优化以及这部分的符号表管理和错误处理工作。

不同的前端和后端组合可以得到不同的编译器。  

### 1.5 交叉编译  
* 嵌入式应用增长的需求，推动了交叉编译技术的发展。
* 交叉编译是指在计算机M1上编译出计算机M2的目标程序。
  * 目前，交叉编译在嵌入式系统开发领域应用相当广泛。通常称M1为宿主机(host)，称M2为目标机(target)。
  * 编译时将应用程序的源程序在宿主机上生成目标机代码。
* 编译程序的目标语言(目标程序) : (object or target  language)(Object or target program)
* 编译程序的源语言(源程序):(Source language)(source program) 
* 编译程序的实现语言:   (Implementation language)

## 2.词法分析（考点为2.2-2.5）
<span id="2"></span>
-------------------------------------------------------
### 2.1 词法分析器的作用  
* **词法分析器(词法分析程序或扫描器)的任务**：从源代码中读取输入字符，按照构词规则切分成一系列单词(token )， 提交给语法分析使用。
  * 识别出源程序中的单词；
      * `java.util.StringTokenizer`
      * `String`类的`split`方法
  * 删除无用的空白字符及注释；
  * 检测出输入的源程序中不能形成源语言任何单词的错误字符串。
* **词法分析器的输出**: Token序列，每个Token包括两个方面的内容:
    * Token = 字符串（词义）+类型（词法）

### 2.2 正规表达式 
#### 2.2.1 基本概念和术语
* **字母表（符号表、符号集）**：由若干元素（符号、字母）组成的有限非空集合称为字母表。
   * 不同的语言有不同的字母表，例如汉语的字母表中包括汉字、数字及标点符号等。
* **符号串**：由字母表中的符号组成的任何有穷序列称为符号串。
   * 字母表A=｛a，b，c｝上的符号串有： a，b，c，ab，aaca等等。
   * 在符号串中，符号的顺序是很重要的，符号串ab不同于ba。
* **符号串的长度**：如果某符号串x中有m个符号，则称其长度为m，表示为｜x｜=m，如001110的长度是6。
* **空符号串ε**，不包含任何符号的符号串，其长度为0，即｜ε｜=0。
* **符号串（包含空符号串）的连接**：设x和y是符号串，它们的连接xy是把y的符号写在x的符号之后得到的符号串。
    * 例如 x=ST，y=abu，则它们的连接 xy=STabu。
    * 由于ε的含义，有εx=xε=x。
* **符号串的方幂**：符号串自身连接n次得到的符号串x的n次方定义为 xx…xx；x的1次方=x, x的2次方=xx，且规定x0=ε。
* **符号串集合（或语言）**：若集合A中所有元素都是某字母表Σ上的符号串，则称A为字母表Σ上的符号串集合（或语言）。

![符号串集合的操作](/storage/符号串集合的操作.png)


#### 2.2.2 正规表达式的定义
* **正规表达式（也称正则表达式）**：是用特定的运算符及运算对象按规则构造的表达式；每个正规表达式匹配（或代表、或表示）一个字符串的集合（称为正规集）。
* 正规表达式的作用：它是描述语言词法规则的形式化工具。 
* **定义**：设有字母表为Σ，辅助字母表Σ’={ф, ε, |  , .  , *  , ( ) }，正规表达式和它所表示的正规集(字符串的集合)的递归定义如下：
   * ε和ф是Σ上的正规式，它们所表示的正规集分别为{ε } 和{ }；
   * 若a∈Σ，则a是Σ上的正规式，它所表示的正规集为{a}；
   * 若r和s是Σ上的正规式，它们所表示的正规集分别为L(r)和L(s)，则：
      * r|s是正规式，表示的正规集为L(r|s)=L(r)∪L(s) ；
      * rs是正规式，表示的正规集为L(rs)=L(r)L(s) ；
      * r* 是正规式，表示的正规集为(L(r))*。
      * (r)是正规式，表示的正规集为L(r)；
    *  有限次使用上述步骤而定义的表达式是Σ上的正规式，由这些正规式所表示的符号串集合是Σ上的正规集。  
  
![正规集举例](/storage/正规集举例.png)
* 给定一个正规式，可以唯一确定一个正规集；但一个正规集，可以由多个不同的正规式表示。

#### 2.2.3 正规表达式的扩展
* **r+**：假设r是正则表达式，r的重复是通过使用标准的闭包运算来描述，写作r*。它允许r被重复0次或更多次。引入r+表示r被重复1次或更多次。
* 任意字符 **.** : 句点 **.** 表示可以匹配除换行符之外的任意单个字符。
* 引号 **“ ”**：引号中的字符串表示文本字符串本身。例如，“. ”表示要匹配 . 字符本身。
* 可选的子表达式 **?** ：引入问号 **?** 表示正规表达式匹配的串是可选的。

#### 2.2.4 单词的正规表达式举例


### 2.3 有穷自动机
#### 2.3.1 有穷自动机的引入
#### 2.3.2 确定性有穷自动机（DFA）的定义
* **确定性有穷自动机(DFA: Deterministic Finite Automata)** 有五个部分组成：
   * 有限个**输入**符号组成的字母表，记作Σ;
   * 有限个**状态**的集合，记作S;
   * **转换函数**T : S×Σ→S
   * **初始状态**s0∈S，指示识别符号串的起始状态；
   * 若干个识别符号串的接受状态(或称为**终止状态**)的集合   A是S的子集；  
  由上述五个要素组成的五元式 **M=(S，Σ，T，s0，A)** 称为一个确定的有限自动机。
* DFA的接受集L(M)：字符串c1 c2 …… cn若被DFA识别或接受，则在状态转换图中存在一条从初态到终态的有向路经，该路径所有矢线上方的字符连接在一起即是字符串c1 c2 …… cn。

#### 2.3.3 非确定性有穷自动机（NFA）
* **非确定性有穷自动机(NFA: Nondeterministic Finite Automata)** 有五个部分组成：
  * 有限个输入符号组成的字母表，记作Σ
  * 有限个状态的集合，记作S；
  * 转换函数T； T: S×( Σ ∪ {ε} )→p(S) 
  * 初始状态s0∈S;
  * 若干个接受状态的集合: A 是 S的子集   
  由上述五个要素组成的五元式 **M=(S，Σ，T，s0，A )** 称为一个非确定的有限自动机。
 

### 2.4 从正规表达式到DFA
#### 2.4.1 正规表达式到NFA
  转化步骤：  
  ![正规表达式到NFA步骤1](/storage/正规表达式到NFA步骤1.png)  
  ![正规表达式到NFA步骤2](/storage/正规表达式到NFA步骤2.png)  
  ![正规表达式到NFA步骤3](/storage/正规表达式到NFA步骤3.png)  
  ![正规表达式到NFA步骤4](/storage/正规表达式到NFA步骤4.png)  

#### 2.4.2 NFA到DFA
对任一NFA M，总可构造一个DFA M’，使 L(M’)=L(M)成立，这就是NFA与DFA的等价性。
* 状态s的ε-闭包：定义为从s出发经过零个或多个ε-转换能达到的状态的集合，并将这个集合记为S上面加一杠；
* 状态集合S的ε-闭包:定义为S中各个状态的ε-闭包的并集。  
  
转化步骤：  
![NFA到DFA步骤1](/storage/NFA到DFA步骤1.png)  
![NFA到DFA步骤2](/storage/NFA到DFA步骤2.png)  
![NFA到DFA步骤3](/storage/NFA到DFA步骤3.png) 

例题：  
![NFA到DFA例题1](/storage/NFA到DFA例题1.png)  
![NFA到DFA例题2](/storage/NFA到DFA例题2.png)   

#### 2.4.3 DFA的状态数最小化
对于任何给定的DFA，存在一个含有**最少状态与之等价的DFA**，而且这个最小状态的DFA在同构意义下是唯一的。
* 对于任意给定的输入串w，若DFA分别从状态s1 ，s2出发，对于否接受w具有相同的结论，则称状态s1，s2位于同一个**等价类**，即
  * 若从s1出发DFA能接受w，则从s2出发DFA也能接受w；  
  * 若从s1出发DFA拒绝w，则从s2出发DFA亦拒绝w。  
  否则称状态s1，s2是**可区分**的。  

DFA最小化步骤：  
![DFA最小化步骤](/storage/DFA最小化步骤.png) 

例题：  
![DFA最小化例题1](/storage/DFA最小化例题1.png)  
![DFA最小化例题2](/storage/DFA最小化例题2.png)  

### 2.5 用代码实现有穷自动机
利用状态变量和嵌套的case测试模拟DFA：  
```pascal
state:=1;
ch:=getchar();
while (state！=3) do
  case state of 
   1:    case ch of
	         letter:  ch:=getchar();
		               state:=2;
	         default: 
                     state:=…{error or other}
         end case;
   2:    case ch  of 
            letter, digit: 
                     ch:=getchar();  
                     state:=2;
	         default: 
                    state:=3;
        end case;
  end case ;
end while;
if  state=3  then accept else error;
```  
* 标识符的DFA可以用二维转换表格表示，其中，空表项表示到错误状态的转换。因为是利用二维表格引导分析过程，被称作表驱动(table driven)算法。
  * 优点：代码的长度较短，相同的代码可以解决不同的问题，代码易于改变（维护）。
  * 缺点：表格会变得非常大，使得程序使用的空间也变得非常大。数组中浪费许多空间。因此，尽管表压缩经常会多耗费时间，但表驱动方法经常仍要依赖于如稀疏数组表示法的压缩方法，来提高扫描程序的效率。

### 2.6 自动生成词法分析程序
可以使用Lex进行生成。
### 2.7 编译器实现（词法分析模块）
实验一：词法分析程序。

## 3.上下文无关法（考点为3.2-3.3） 
<span id="3"></span>
----------------------------------------
### 3.1 语言的表示  
Noam Chomsky研究了自然语言的结构，提出了一种描述语言的数学系统(Chomsky文法)，并以此定义了四类性质不同的文法(0型，1型，2型和3型文法)，称为语言（文法）的Chomsky分类。其中2型文法（或上下文无关文法）对程序设计语言是最有用的，它可以作为程序设计语言语法结构描述的标准方式。Chomsky文法用生成方式(规则)描述语言，语言中的每个句子用严格定义的规则构造。

### 3.2 上下文无关法的形式定义
* 上下文无关文法G是一个四元组，即**G=(VT，VN，P，S)**：
  * **终结符（或Token）集合**VT
  * **非终结符集合**VN(与VT不相交)
  * **产生式或文法规则**A→α形成的集合P,  其中A∈VN，α∈(VT ∪ VN)*
  * **开始符号**S，其中S∈VN
* **直接推导**就是产生式规则的一次运用，即用产生式的右部替换左部。
* 句型和句子：设G=(VN , VT , P , S)是一文法,且 V=VN ∪ VT：
  * 若S =>*α，α∈V*，则称α为文法G的句型。
  * 若S=>+α，α∈VT*，则称α为文法G的句子。
* **最左推导**：对于文法G[S]，S推导到*γ 是一个最左推导是指：在由S推导γ的过程中，任何一步直接推导α推导到β，都是用字符串α中的最左非终结符对应的产生式规则进行推导，其中α、β是句型。
* **最右推导（又称规范推导）**：S推导到*γ是一个最右推导是指：在由S推导γ的过程中，任何一步直接推导α推导到β，都是用字符串α中的最右非终结符对应的产生式规则进行推导，其中α、β是句型。
  
* 设给定2型文法G=(VN , VT , P , S)，若存在产生式A→xAy∈P ，则称产生式A→xAy是递归产生式； x，y∈(VN ∪ VT)*   
  * 若x=ε且y≠ε,则称产生式A→Ay是**左递归产生式**；
  * 若x≠ε且y=ε,则称产生式A→xA是**右递归产生式**。  
若文法中至少存在一条递归产生式则称该文法是**直接递归的文法**；


### 3.3 分析树
* 句子的每一个推导过程都对应一个分析树，分析树的定义：
  * 每个节点都用终结符、非终结符或ε标出；
  * 根结点用文法的开始符号S标出；
  * 每个叶结点都用终结符或ε标出；
  * 每个非叶结点都用非终符标出；
  * 每一步直接推导对应一个子树：在分析树中，如果标记为A∈VN的节点有n个标记为X1,X2,…Xn的孩子，如下图所示，Xi可以是终结符也可以是非终结符，则文法G中有对应的产生式 A→X1X2…Xn ∈ P；  
  ![分析树定义](/storage/分析树定义.png)


### 3.4 二义性文法
* 对于文法G，若存在某个句子w ∈ L(G)， w对应多个不同的最左推导（或最右推导），这类文法称为**二义性文法**。  
* 为解决二义性文法的不确定性，通常有两种方法：
  * 修改文法
  * 通常采用设置消除二义性的规则，例如：优先权和结合性。
* 如果一个文法含有既是左递归又是右递归的文法符号，则必定是二义性的。

## 4.语法分析（考点为第一部分的4.2-4.3，第二部分的4.3-4.6）
<span id="4"></span>
--------------------------------------------------------
### 4.1 自上而下的语法分析概述
自上而下的语法分析算法：  
* 已知文法G[S]，对任意输入串w，若从文法的开始符号S出发, 能为w构造一个最左推导，则w是一个合法的句子，即w ∈ L(G)，否则w有语法错误。
* 该算法自上而下为w的分析结果建立一棵语法树。

### 4.2 递归下降分析（Recursive-Descent Top-Down Parsing） 
#### 4.2.1 递归下降分析的基本方法
* **递归下降分析方法**是一种自上而下的语法分析方法，该方法执行一组递归函数判断输入的单词序列是否符合语法规则。
* 递归函数如何写？   
为每个产生式规则撰写一个函数，以产生式左部的非终结符作为函数的名子，根据产生式规则的右部撰写函数体。
  * 遇到终结符，匹配并读取下一个单词；
  * 遇到非终结符，调用该非终结符所在产生式对应的函数；

```Java
//识别S的递归下降伪代码
void S(void){ 
   match(c);
   A(); 
   match(d);
}

void A(void){  
   match(a);
   match(b); 
}

void match(TokenType tokenExpected) {
 if (currentToken.tokentype == tokenExpected){   
      currentToken = scanner.getToken();
     } else {
        error: "tokenExpected" expected
        but "currentToken" found
        }
}
```

#### 4.2.2 文法规则使用EBNF表示法
如果语法分析方法使用递归下降分析程序,为了避免重复扫描词法分析输出的单词序列(提高效率)，需要先将文法G采用EBNF表示法，然后写出递归下降分析程序。
* 选择的情况。EBNF使用[ ]表示选择。代码中使用if-else来实现。相较于不使用，避免了重复扫描单词序列。
* 重复的情况。EBNF使用{ }表示重复。代码中使用循环来实现。

#### 4.2.3 其它应注意的问题
递归下降可能会出现问题：  
1. 间接递归的文法(会导致死循环，要将文法进行相应处理)。   
  例如：文法G[S]: S → Ab|c ， A → Sa，试写出它的递归下降分析程序。  
  避免分析程序死循环的解决办法：  
  可将间接递归的文法进行等价改造为S→Sab|c，进而改造为：S → c{ab}。  
2. 对于两个或多个文法规则的选项A → α | β | … ， 如果α和β均以非终结符开始，那么就很难决定何时使用A → α选项，何时又使用A → β选项，这样撰写的递归下降分析程序就存在回溯。  
  解决办法：计算α和β的First集合（LL(1)分析方法给出定义和求解方法）。

#### 4.2.4 分析树与抽象语法树
分析树对于显示程序的各语法单位或程序的单词序列很有帮助，但是相比纯粹为编译生成可执行代码所需的信息而言，分析树却包括了冗余的信息。所以语法分析程序更趋向于生成抽象语法树，抽象语法树是分析树中所含信息的浓缩，包含了进一步分析所需的所有信息，比分析树效率高。  

### 4.3 LL（1）分析
#### 4.3.1 LL(1)分析的基本方法
* LL (1)分析方法是一种自上而下的语法分析方法：
  * 第1个“L”指的是由左向右地处理输入；
  * 第2个“L”指的是它为输入串找出一个最左推导；
  * 括号中的数字1意味着它使用输入单词序列中的一个单词预测分析的动作。

#### 4.3.2 LL(1)分析与算法
LL (1)分析方法如下：
1. 通过栈来“记忆”针对当前句型中的哪一个非终结符进行推导，首先将文法的开始符号S入栈；
   * 如果栈的顶部是非终结符A,则利用A对应的某个文法规则A → α将栈顶部的非终结符A(出栈)替换成串α(将串α自右至左入栈)。
    * 如果栈的顶部是终结符a,则查看已推出的终结符是否与当前输入单词匹配？(如匹配则出栈)。
2. 构造一个非终结符和终结符索引的二维表格M[N，T]，通过表格指出用哪一个产生式进行进行下一步推导，其中N是非终结符的集合，T是终结符的集合。

**如何构造LL(1)分析表？**
1. **求First集合**  
   若X可推导出以终结符a为首的字符串，则a在First(X)中。
   1. 若X是终结符或ε，则First(X)={X}
   2. 若X是非终结符，则对于X对应的每个产生式X→X1X2...Xn
     * First(X)包括 First(X1)-{ε}。
     * 若对于某个i<n，所有的集合First(X1),…,First(Xi)都包括了ε，则First(X)也包括First(Xi+1)-{ε}。
     * 若所有集合First (X1),..., First(Xn)包括了ε，则First(X)也包括ε。

例题：  
问题：        
![求First集合问题](/storage/求First集合问题.png)  

答案：   
![求First集合问题](/storage/求First集合问题.png)   

2. **求Follow集合**
   1. 若A是开始符号,则Follow(A)包含$
   2. 若存在产生式B → α A γ,则Follow(A)包含     	First(γ)-{ε}
   3. 若存在产生式B → α A γ，且ε在First(γ)中，则
   Follow(A)包含Follow(B)     

例题：  
问题：  
![求First集合问题](/storage/求First集合问题.png)   
答案：  
![求Follow集合答案](/storage/求Follow集合答案.png)   
   
3. **构造分析表**  
   分析表以非终结符作为行索引，以终结符作为列索引，分析表的元素位置存储产生式，为每个非终结符A和它对应的产生式A → α重复以下两步骤：
   1. 对于First( α )中的每个终结符a，都将A→α添加到M[A,a]元素位置，置M[A,a] =“A → α”。
   2. 若ε在First( α )中，则对于Follow(A)的每个元素a(或是$)，都将A → α添加到 M[A,a]中。即在此情况下按产生式A → α进行推导。   
   3. 所有没有定义的元素位置M[A,a]标上“出错”标志。

注：如果文法G相关的LL(1)分析表的每个项目中至多只有一个产生式，则该文法就是LL(1)文法。

#### 4.3.3 消除左递归和提取左因子
由于含有左递归和左公共因子的文法不是LL(1)文法，如果要使用LL(1)语法分析算法对该文法定义的语言进行语法分析，那么必须通过消除左递归和提取左公共因子，将文法进行等价改造。

改造方法：
  1. 简单直接左递归的消除。  
     A → Aα  
     A → β  
     重写为：  
     A → βB  
     B → αB|ε  
  2. 多项直接左递归的消除。  
     A → Aα1 | Aα2 | … | Aαn | β1 | β2 | … | βm  
     重写为：  
     A → β1B | β2B | … | βmB  
     B → α1B | α2B | … | αnB | ε  
  3. 提取左因子。  
     若有产生式U → xy | xw | … | xz ，则提取左公共因子并用EBNF表示为： U → x ( y | w | … | z )  再引入另一个非终结符号V，将产生式变为：  
     U → xV  
     V → y | w | … | z  



### 4.4 自上而下的语法分析器自动生成工具——JavaCC

### 4.5 编译器实现（语法分析模块）
实验二：语法分析程序

## 5.语义分析（考点为5.1）
<span id="5"></span>
-------------------------------------------------------

## 6.中间代码生成（考点为6.2-6.4）
<span id="6"></span>
--------------------------------------------------------

## 7.运行时环境（考点为7.1和7.3）
<span id="7"></span>
--------------------------------------------------------



