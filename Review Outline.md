# 编译原理复习提纲

## 目录
---------
### 1. [编译器工作过程](#1)
### 2. [词法分析](#2)
### 3. [上下文无关法](#3)
### 4. [语法分析](#4)
### 5. [语义分析](#5)
### 6. [中间代码生成](#6)  
### 7. [运行时环境](#7)
   
## 1.编译器工作过程（非考点）
<span id="1"></span>
--------------------
### 1.1 编译器（compiler）的发展  
* **第一代编程语言**：20世纪40年代，冯•诺伊曼存储—程序计算机，编写一串代码或程序成为必要，开始用机器语言编写程序。
* **第二代编程语言**：汇编语言。汇编程序将汇编语言程序的符号代码和存储地址翻译成与之等价的机器码。  
* **第三代编程语言**：高级语言。类似于数学定义或自然语言的简洁形式来编写程序，与机器无关。 
 
**编译器的定义**：把计算机高级语言(源语言)编写的程序(源程序)翻译成该计算机的汇编语言或机器语言(目标语言)书写的程序(目标程序)的计算机程序称为编译器(或编译程序)。   

### 1.2 解释程序（interpreter）  
解释程序是如同编译器的一种语言翻译程序，与编译器不同之处在于：
* 它以源程序为输入，在执行过程中不产生目标程序（代码），而是边解释边执行，即直接执行源程序中蕴含的操作。
* 解释程序实现简单，易于在解释执行过程中插入修改和调试措施，但边解释边执行的方式工作效率低，可能需要重复翻译和执行语句，它经常用于执行命令语言(Python)和交互式会话语言程序的执行等。
* 编译执行和解释执行是两种最基本的运行程序的途径。
  
### 1.3 编译器构造逻辑阶段的划分
![编译器逻辑结构](/storage/编译器构造逻辑阶段划分.png)  

* **词法分析程序**：逐个读入源程序字符并按照构词规则切分成一系列单词(token)。单词是语言中具有独立意义的最小单位，包括保留字、标识符、运算符、标点符号和常量等。
* **语法分析程序**：语法分析以词法分析程序输出的单词序列(或流)为输入，分析源程序的语法结构，判断它是否为相应程序设计语言的合法程序，并可以确定单词流中违反源语言语法结构规则的错误。
* **语义分析程序**：语义分析是在语法分析程序确定出语法短语后，审查有无语义错误，并为代码生成阶段收集符号属性信息。
* **中间代码生成**：为了处理方便和便于代码优化，通常在语义分析后并不直接产生目标代码，而是生成介于源代码和目标代码二者之间的中间代码。
* **代码优化程序**：代码优化工作可以在不同的编译阶段进行，其中对中间代码的优化尤其重要。为了使生成的目标代码更为高效，可以对产生的中间代码进行等价变换或改造（称为代码的优化）。
* **目标代码生成**：将中间代码翻译成为目标程序。通常目标代码可采用如下三种形式之一：
   * 具有绝对地址的机器指令代码。
   * 模块结构的机器指令。
   * 汇编语言形式的目标程序。
* **常数表**：常数表的功能是存放在编译过程中用到的常量和字符串，快速插入和查找操作在常数表中十分重要。由于常数表的数据在整个编译过程中都被用到，所以无需在常数表中进行删除操作。
* **符号表**：符号表存储函数、变量、常量以及数据类型等标识符相关的信息。符号表用于以下情况：
  * 在词法分析、语法分析和语义分析的过程中收集有关标识符的属性，并存于符号表中。
  * 作为进行语法和语义的合法性检查的依据。例如，同一个标识符可能在程序的不同地方出现，需要检查标识符在上下文中的一致性和合法性，而符号表正是进行这种检查的依据；
* **错误处理器**：在编译的每一个阶段，编译器对源程序中错误的反应是其重要功能之一。
  
### 1.4 编译阶段的组合——前端与后端
* **前端（Front-End）**：与目标机无关的部分。包括分析部分(词法、语法、语义分析)、中间代码生成与优化以及这部分的符号表管理错误处理。
*  **后端（Back-End）**：与目标机有关部分。包括目标代码生成、与目标机有关的优化以及这部分的符号表管理和错误处理工作。

不同的前端和后端组合可以得到不同的编译器。  

### 1.5 交叉编译  
* 嵌入式应用增长的需求，推动了交叉编译技术的发展。
* 交叉编译是指在计算机M1上编译出计算机M2的目标程序。
  * 目前，交叉编译在嵌入式系统开发领域应用相当广泛。通常称M1为宿主机(host)，称M2为目标机(target)。
  * 编译时将应用程序的源程序在宿主机上生成目标机代码。
* 编译程序的目标语言(目标程序) : (object or target  language)(Object or target program)
* 编译程序的源语言(源程序):(Source language)(source program) 
* 编译程序的实现语言:   (Implementation language)

## 2.词法分析（考点为2.2-2.5）
<span id="2"></span>
-------------------------------------------------------
### 2.1 词法分析器的作用  
* **词法分析器(词法分析程序或扫描器)的任务**：从源代码中读取输入字符，按照构词规则切分成一系列单词(token )， 提交给语法分析使用。
  * 识别出源程序中的单词；
      * `java.util.StringTokenizer`
      * `String`类的`split`方法
  * 删除无用的空白字符及注释；
  * 检测出输入的源程序中不能形成源语言任何单词的错误字符串。
* **词法分析器的输出**: Token序列，每个Token包括两个方面的内容:
    * Token = 字符串（词义）+类型（词法）

### 2.2 正规表达式 
#### 2.2.1 基本概念和术语
* **字母表（符号表、符号集）**：由若干元素（符号、字母）组成的有限非空集合称为字母表。
   * 不同的语言有不同的字母表，例如汉语的字母表中包括汉字、数字及标点符号等。
* **符号串**：由字母表中的符号组成的任何有穷序列称为符号串。
   * 字母表A=｛a，b，c｝上的符号串有： a，b，c，ab，aaca等等。
   * 在符号串中，符号的顺序是很重要的，符号串ab不同于ba。
* **符号串的长度**：如果某符号串x中有m个符号，则称其长度为m，表示为｜x｜=m，如001110的长度是6。
* **空符号串ε**，不包含任何符号的符号串，其长度为0，即｜ε｜=0。
* **符号串（包含空符号串）的连接**：设x和y是符号串，它们的连接xy是把y的符号写在x的符号之后得到的符号串。
    * 例如 x=ST，y=abu，则它们的连接 xy=STabu。
    * 由于ε的含义，有εx=xε=x。
* **符号串的方幂**：符号串自身连接n次得到的符号串x的n次方定义为 xx…xx；x的1次方=x, x的2次方=xx，且规定x0=ε。
* **符号串集合（或语言）**：若集合A中所有元素都是某字母表Σ上的符号串，则称A为字母表Σ上的符号串集合（或语言）。

![符号串集合的操作](/storage/符号串集合的操作.png)


#### 2.2.2 正规表达式的定义
* **正规表达式（也称正则表达式）**：是用特定的运算符及运算对象按规则构造的表达式；每个正规表达式匹配（或代表、或表示）一个字符串的集合（称为正规集）。
* 正规表达式的作用：它是描述语言词法规则的形式化工具。 
* **定义**：设有字母表为Σ，辅助字母表Σ’={ф, ε, |  , .  , *  , ( ) }，正规表达式和它所表示的正规集(字符串的集合)的递归定义如下：
   * ε和ф是Σ上的正规式，它们所表示的正规集分别为{ε } 和{ }；
   * 若a∈Σ，则a是Σ上的正规式，它所表示的正规集为{a}；
   * 若r和s是Σ上的正规式，它们所表示的正规集分别为L(r)和L(s)，则：
      * r|s是正规式，表示的正规集为L(r|s)=L(r)∪L(s) ；
      * rs是正规式，表示的正规集为L(rs)=L(r)L(s) ；
      * r* 是正规式，表示的正规集为(L(r))*。
      * (r)是正规式，表示的正规集为L(r)；
    *  有限次使用上述步骤而定义的表达式是Σ上的正规式，由这些正规式所表示的符号串集合是Σ上的正规集。  
  
![正规集举例](/storage/正规集举例.png)
* 给定一个正规式，可以唯一确定一个正规集；但一个正规集，可以由多个不同的正规式表示。

#### 2.2.3 正规表达式的扩展
* **r+**：假设r是正则表达式，r的重复是通过使用标准的闭包运算来描述，写作r*。它允许r被重复0次或更多次。引入r+表示r被重复1次或更多次。
* 任意字符 **.** : 句点 **.** 表示可以匹配除换行符之外的任意单个字符。
* 引号 **“ ”**：引号中的字符串表示文本字符串本身。例如，“. ”表示要匹配 . 字符本身。
* 可选的子表达式 **?** ：引入问号 **?** 表示正规表达式匹配的串是可选的。

#### 2.2.4 单词的正规表达式举例


### 2.3 有穷自动机
#### 2.3.1 有穷自动机的引入
#### 2.3.2 确定性有穷自动机（DFA）的定义
* **确定性有穷自动机(DFA: Deterministic Finite Automata)** 有五个部分组成：
   * 有限个**输入**符号组成的字母表，记作Σ;
   * 有限个**状态**的集合，记作S;
   * **转换函数**T : S×Σ→S
   * **初始状态**s0∈S，指示识别符号串的起始状态；
   * 若干个识别符号串的接受状态(或称为**终止状态**)的集合   A是S的子集；  
  由上述五个要素组成的五元式 **M=(S，Σ，T，s0，A)** 称为一个确定的有限自动机。
* DFA的接受集L(M)：字符串c1 c2 …… cn若被DFA识别或接受，则在状态转换图中存在一条从初态到终态的有向路经，该路径所有矢线上方的字符连接在一起即是字符串c1 c2 …… cn。

#### 2.3.3 非确定性有穷自动机（NFA）
* **非确定性有穷自动机(NFA: Nondeterministic Finite Automata)** 有五个部分组成：
  * 有限个输入符号组成的字母表，记作Σ
  * 有限个状态的集合，记作S；
  * 转换函数T； T: S×( Σ ∪ {ε} )→p(S) 
  * 初始状态s0∈S;
  * 若干个接受状态的集合: A 是 S的子集   
  由上述五个要素组成的五元式 **M=(S，Σ，T，s0，A )** 称为一个非确定的有限自动机。
 

### 2.4 从正规表达式到DFA
#### 2.4.1 正规表达式到NFA
  转化步骤：  
  ![正规表达式到NFA步骤1](/storage/正规表达式到NFA步骤1.png)  
  ![正规表达式到NFA步骤2](/storage/正规表达式到NFA步骤2.png)  
  ![正规表达式到NFA步骤3](/storage/正规表达式到NFA步骤3.png)  
  ![正规表达式到NFA步骤4](/storage/正规表达式到NFA步骤4.png)  

#### 2.4.2 NFA到DFA
对任一NFA M，总可构造一个DFA M’，使 L(M’)=L(M)成立，这就是NFA与DFA的等价性。
* 状态s的ε-闭包：定义为从s出发经过零个或多个ε-转换能达到的状态的集合，并将这个集合记为S上面加一杠；
* 状态集合S的ε-闭包:定义为S中各个状态的ε-闭包的并集。  
  
转化步骤：  
![NFA到DFA步骤1](/storage/NFA到DFA步骤1.png)  
![NFA到DFA步骤2](/storage/NFA到DFA步骤2.png)  
![NFA到DFA步骤3](/storage/NFA到DFA步骤3.png) 

例题：  
![NFA到DFA例题1](/storage/NFA到DFA例题1.png)  
![NFA到DFA例题2](/storage/NFA到DFA例题2.png)   

#### 2.4.3 DFA的状态数最小化
对于任何给定的DFA，存在一个含有**最少状态与之等价的DFA**，而且这个最小状态的DFA在同构意义下是唯一的。
* 对于任意给定的输入串w，若DFA分别从状态s1 ，s2出发，对于否接受w具有相同的结论，则称状态s1，s2位于同一个**等价类**，即
  * 若从s1出发DFA能接受w，则从s2出发DFA也能接受w；  
  * 若从s1出发DFA拒绝w，则从s2出发DFA亦拒绝w。  
  否则称状态s1，s2是**可区分**的。  

DFA最小化步骤：  
![DFA最小化步骤](/storage/DFA最小化步骤.png) 

例题：  
![DFA最小化例题1](/storage/DFA最小化例题1.png)  
![DFA最小化例题2](/storage/DFA最小化例题2.png)  

### 2.5 用代码实现有穷自动机
利用状态变量和嵌套的case测试模拟DFA：  
```pascal
state:=1;
ch:=getchar();
while (state！=3) do
  case state of 
   1:    case ch of
	         letter:  ch:=getchar();
		               state:=2;
	         default: 
                     state:=…{error or other}
         end case;
   2:    case ch  of 
            letter, digit: 
                     ch:=getchar();  
                     state:=2;
	         default: 
                    state:=3;
        end case;
  end case ;
end while;
if  state=3  then accept else error;
```  
* 标识符的DFA可以用二维转换表格表示，其中，空表项表示到错误状态的转换。因为是利用二维表格引导分析过程，被称作表驱动(table driven)算法。
  * 优点：代码的长度较短，相同的代码可以解决不同的问题，代码易于改变（维护）。
  * 缺点：表格会变得非常大，使得程序使用的空间也变得非常大。数组中浪费许多空间。因此，尽管表压缩经常会多耗费时间，但表驱动方法经常仍要依赖于如稀疏数组表示法的压缩方法，来提高扫描程序的效率。

### 2.6 自动生成词法分析程序
可以使用Lex进行生成。
### 2.7 编译器实现（词法分析模块）
实验一：词法分析程序。

## 3.上下文无关法（考点为3.2-3.3） 
<span id="3"></span>
----------------------------------------
### 3.1 语言的表示  
Noam Chomsky研究了自然语言的结构，提出了一种描述语言的数学系统(Chomsky文法)，并以此定义了四类性质不同的文法(0型，1型，2型和3型文法)，称为语言（文法）的Chomsky分类。其中2型文法（或上下文无关文法）对程序设计语言是最有用的，它可以作为程序设计语言语法结构描述的标准方式。Chomsky文法用生成方式(规则)描述语言，语言中的每个句子用严格定义的规则构造。

### 3.2 上下文无关法的形式定义
* 上下文无关文法G是一个四元组，即**G=(VT，VN，P，S)**：
  * **终结符（或Token）集合**VT
  * **非终结符集合**VN(与VT不相交)
  * **产生式或文法规则**A→α形成的集合P,  其中A∈VN，α∈(VT ∪ VN)*
  * **开始符号**S，其中S∈VN
* **直接推导**就是产生式规则的一次运用，即用产生式的右部替换左部。
* 句型和句子：设G=(VN , VT , P , S)是一文法,且 V=VN ∪ VT：
  * 若S =>*α，α∈V*，则称α为文法G的句型。
  * 若S=>+α，α∈VT*，则称α为文法G的句子。
* **最左推导**：对于文法G[S]，S推导到*γ 是一个最左推导是指：在由S推导γ的过程中，任何一步直接推导α推导到β，都是用字符串α中的最左非终结符对应的产生式规则进行推导，其中α、β是句型。
* **最右推导（又称规范推导）**：S推导到*γ是一个最右推导是指：在由S推导γ的过程中，任何一步直接推导α推导到β，都是用字符串α中的最右非终结符对应的产生式规则进行推导，其中α、β是句型。
  
* 设给定2型文法G=(VN , VT , P , S)，若存在产生式A→xAy∈P ，则称产生式A→xAy是递归产生式； x，y∈(VN ∪ VT)*   
  * 若x=ε且y≠ε,则称产生式A→Ay是**左递归产生式**；
  * 若x≠ε且y=ε,则称产生式A→xA是**右递归产生式**。  
若文法中至少存在一条递归产生式则称该文法是**直接递归的文法**；


### 3.3 分析树
* 句子的每一个推导过程都对应一个分析树，分析树的定义：
  * 每个节点都用终结符、非终结符或ε标出；
  * 根结点用文法的开始符号S标出；
  * 每个叶结点都用终结符或ε标出；
  * 每个非叶结点都用非终符标出；
  * 每一步直接推导对应一个子树：在分析树中，如果标记为A∈VN的节点有n个标记为X1,X2,…Xn的孩子，如下图所示，Xi可以是终结符也可以是非终结符，则文法G中有对应的产生式 A→X1X2…Xn ∈ P；  
  ![分析树定义](/storage/分析树定义.png)


### 3.4 二义性文法
* 对于文法G，若存在某个句子w ∈ L(G)， w对应多个不同的最左推导（或最右推导），这类文法称为**二义性文法**。  
* 为解决二义性文法的不确定性，通常有两种方法：
  * 修改文法
  * 通常采用设置消除二义性的规则，例如：优先权和结合性。
* 如果一个文法含有既是左递归又是右递归的文法符号，则必定是二义性的。

## 4.语法分析（考点为第一部分的4.2-4.3，第二部分的4.3-4.6）
<span id="4"></span>
--------------------------------------------------------

**第一部分**
---------------------
### 4.1 自上而下的语法分析概述
自上而下的语法分析算法：  
* 已知文法G[S]，对任意输入串w，若从文法的开始符号S出发, 能为w构造一个最左推导，则w是一个合法的句子，即w ∈ L(G)，否则w有语法错误。
* 该算法自上而下为w的分析结果建立一棵语法树。

### 4.2 递归下降分析（Recursive-Descent Top-Down Parsing） 
#### 4.2.1 递归下降分析的基本方法
* **递归下降分析方法**是一种自上而下的语法分析方法，该方法执行一组递归函数判断输入的单词序列是否符合语法规则。
* 递归函数如何写？   
为每个产生式规则撰写一个函数，以产生式左部的非终结符作为函数的名子，根据产生式规则的右部撰写函数体。
  * 遇到终结符，匹配并读取下一个单词；
  * 遇到非终结符，调用该非终结符所在产生式对应的函数；

```Java
//识别S的递归下降伪代码
void S(void){ 
   match(c);
   A(); 
   match(d);
}

void A(void){  
   match(a);
   match(b); 
}

void match(TokenType tokenExpected) {
 if (currentToken.tokentype == tokenExpected){   
      currentToken = scanner.getToken();
     } else {
        error: "tokenExpected" expected
        but "currentToken" found
        }
}
```

#### 4.2.2 文法规则使用EBNF表示法
如果语法分析方法使用递归下降分析程序,为了避免重复扫描词法分析输出的单词序列(提高效率)，需要先将文法G采用EBNF表示法，然后写出递归下降分析程序。
* 选择的情况。EBNF使用[ ]表示选择。代码中使用if-else来实现。相较于不使用，避免了重复扫描单词序列。
* 重复的情况。EBNF使用{ }表示重复。代码中使用循环来实现。

#### 4.2.3 其它应注意的问题
递归下降可能会出现问题：  
1. 间接递归的文法(会导致死循环，要将文法进行相应处理)。   
  例如：文法G[S]: S → Ab|c ， A → Sa，试写出它的递归下降分析程序。  
  避免分析程序死循环的解决办法：  
  可将间接递归的文法进行等价改造为S→Sab|c，进而改造为：S → c{ab}。  
2. 对于两个或多个文法规则的选项A → α | β | … ， 如果α和β均以非终结符开始，那么就很难决定何时使用A → α选项，何时又使用A → β选项，这样撰写的递归下降分析程序就存在回溯。  
  解决办法：计算α和β的First集合（LL(1)分析方法给出定义和求解方法）。

#### 4.2.4 分析树与抽象语法树
分析树对于显示程序的各语法单位或程序的单词序列很有帮助，但是相比纯粹为编译生成可执行代码所需的信息而言，分析树却包括了冗余的信息。所以语法分析程序更趋向于生成抽象语法树，抽象语法树是分析树中所含信息的浓缩，包含了进一步分析所需的所有信息，比分析树效率高。  

### 4.3 LL（1）分析
#### 4.3.1 LL(1)分析的基本方法
* LL (1)分析方法是一种自上而下的语法分析方法：
  * 第1个“L”指的是由左向右地处理输入；
  * 第2个“L”指的是它为输入串找出一个最左推导；
  * 括号中的数字1意味着它使用输入单词序列中的一个单词预测分析的动作。

#### 4.3.2 LL(1)分析与算法
LL (1)分析方法如下：
1. 通过栈来“记忆”针对当前句型中的哪一个非终结符进行推导，首先将文法的开始符号S入栈；
   * 如果栈的顶部是非终结符A,则利用A对应的某个文法规则A → α将栈顶部的非终结符A(出栈)替换成串α(将串α自右至左入栈)。
    * 如果栈的顶部是终结符a,则查看已推出的终结符是否与当前输入单词匹配？(如匹配则出栈)。
2. 构造一个非终结符和终结符索引的二维表格M[N，T]，通过表格指出用哪一个产生式进行进行下一步推导，其中N是非终结符的集合，T是终结符的集合。

**如何构造LL(1)分析表？**
1. **求First集合**  
   若X可推导出以终结符a为首的字符串，则a在First(X)中。
   1. 若X是终结符或ε，则First(X)={X}
   2. 若X是非终结符，则对于X对应的每个产生式X→X1X2...Xn
     * First(X)包括 First(X1)-{ε}。
     * 若对于某个i<n，所有的集合First(X1),…,First(Xi)都包括了ε，则First(X)也包括First(Xi+1)-{ε}。
     * 若所有集合First (X1),..., First(Xn)包括了ε，则First(X)也包括ε。

例题：  
问题：        
![求First集合问题](/storage/求First集合问题.png)  

答案：   
![求First集合问题](/storage/求First集合问题.png)   

2. **求Follow集合**
   1. 若A是开始符号,则Follow(A)包含$
   2. 若存在产生式B → α A γ,则Follow(A)包含     	First(γ)-{ε}
   3. 若存在产生式B → α A γ，且ε在First(γ)中，则
   Follow(A)包含Follow(B)     

例题：  
问题：  
![求First集合问题](/storage/求First集合问题.png)   
答案：  
![求Follow集合答案](/storage/求Follow集合答案.png)   
   
3. **构造分析表**  
   分析表以非终结符作为行索引，以终结符作为列索引，分析表的元素位置存储产生式，为每个非终结符A和它对应的产生式A → α重复以下两步骤：
   1. 对于First( α )中的每个终结符a，都将A→α添加到M[A,a]元素位置，置M[A,a] =“A → α”。
   2. 若ε在First( α )中，则对于Follow(A)的每个元素a(或是$)，都将A → α添加到 M[A,a]中。即在此情况下按产生式A → α进行推导。   
   3. 所有没有定义的元素位置M[A,a]标上“出错”标志。

注：如果文法G相关的LL(1)分析表的每个项目中至多只有一个产生式，则该文法就是LL(1)文法。

#### 4.3.3 消除左递归和提取左因子
由于含有左递归和左公共因子的文法不是LL(1)文法，如果要使用LL(1)语法分析算法对该文法定义的语言进行语法分析，那么必须通过消除左递归和提取左公共因子，将文法进行等价改造。

改造方法：
  1. 简单直接左递归的消除。  
     A → Aα  
     A → β  
     重写为：  
     A → βB  
     B → αB|ε  
  2. 多项直接左递归的消除。  
     A → Aα1 | Aα2 | … | Aαn | β1 | β2 | … | βm  
     重写为：  
     A → β1B | β2B | … | βmB  
     B → α1B | α2B | … | αnB | ε  
  3. 提取左因子。  
     若有产生式U → xy | xw | … | xz ，则提取左公共因子并用EBNF表示为： U → x ( y | w | … | z )  再引入另一个非终结符号V，将产生式变为：  
     U → xV  
     V → y | w | … | z  

### 4.4 自上而下的语法分析器自动生成工具——JavaCC
一个自上而下的LL(k)解析器，默认情况下生成LL(1)分析程序。
### 4.5 编译器实现（语法分析模块）
实验二：语法分析程序

**第二部分**
----------------------------------
### 4.1 自下而上的语法分析概览
* 从输入单词序列开始，自左至右逐步进行归约，试图将其归约为文法的开始符号。从输入单词序列开始，以单词做为语法树的叶节点，自底向上地构造语法分析的结果———语法树。
* 自左至右规约是规范（最右）推导的逆过程, 称之为**规范规约**。
* 在自下而上语法分析工作的每一步，都是从当前串中选择一个子串，将它归约到某个非终结符号。我们将每次规约的子串称为句柄
### 4.2 LR分析概览
LR分析法是一种有效的自下而上的语法分析技术，它能适用于大部分上下文无关文法的分析，一般叫LR(k)分析方法，其中
* L是指自左(Left)向右分析输入单词序列。
* R是指分析过程都是构造最右(Right)推导的逆过程(规范归约)。
* 括号中的k是指在决定当前分析动作时向右看的单词个数。

这种方法应用更广泛，因为能识别所有采用上下文无关法描述的语法结构，是无回溯的移进-规约方法，容易查错。

### 4.3 LR(0)项目的有穷自动机与LR(0)分析
#### 4.3.1 构造识别活前缀的NFA
* **项目**：对于文法G，其产生式的右部添加一个特殊符号“.”就构成文法的一个LR(0)项目，简称项目。若A → βγ是产生式，其中β和γ是任意符号串（包括空串），那么A → β. γ就是LR(0)项目。每个项目中圆点的左部表示在分析过程中，要用该产生式归约时，句柄已识别的部分(进入符号栈)，右部表示等待识别的部分。
* NFA的构造原则:为了确保有唯一的接受项目，首先拓广文法G为G’,引进一新的产生式S’ →  S ， S’是新增加的非终结符作为G’的开始符。
  1. NFA的状态集：每个项目对应一个NFA状态，所有项目对应的状态的集合；
  2. 输入字符集合：包括终结符、非终结符和ε
  3. 初态：对于文法G[S]的拓广文法G[S’],有项目S’ → . S ,由于S’仅在第一个产生式的左部出现，规定它为初态；
  4. 终态：对于拓广文法G[S’]，有项目U → u. (即圆点在最后的项目)，作为NFA的终态；
  5. 转换函数f
     若文法中有项目i为：X → x1…xi-1.xi…xn  
     项目j为：X → x1…xi.xi+1…xn  
     1) 则有转换函数GO(i，xi)=j
     2) 若xi为非终结符号，则还有转换函数GO (i, xj)=k
   项目k为：xi → . β 

#### 4.3.2 构造识别活前缀的DFA
基于闭包函数CLOSURE(I)以及转移函数GO(I，x)构造识别活前缀的DFA;
* 拓广文法G’的一个LR(0)项目集合I的闭包函数CLOSURE(I)的定义如下：
  1. 步骤1：令 CLOSURE(I)=I；
  2. 步骤2：若项目A → α . Bβ ∈ CLOSURE(I), B ∈ VN ,则CLOSURE(I) = CLOSURE(I) ∪ {B→.γ}；
  3. 步骤3：重复步骤2直至CLOSURE(I) 不增加新的项目为止。
* I是一个项目集， x ∈ VN ∪ VT，状态转移函数GO(I，x)的定义如下：     
GO(I，x)= CLOSURE(J)，其中：
J是I识别输入符号x后所到达的项目集， J= {A → αx.β | A → α.xβ ∈ I }  

* **基于闭包函数CLOSURE(I)和转移函数GO(I，x)构造识别文法活前缀的DFA的算法如下**：
  1. 令项目集CLOSURE({S’ → .S })为DFA的初态；
  2. 输入字符集合：包括终结符、非终结符；
  3. 设I是DFA中一个已存在的状态(项目集)，若存在A →α.xβ ∈ I，则对x∈ VN ∪ VT ，
    * 计算GO(I，x)= CLOSURE(J)，将项目集 CLOSURE(J) 作为DFA的一个新状态加入DFA的状态集；
    * 同时将转移函数GO(I，x)= CLOSURE(J)作为DFA的转换函数。  
  4. 重复2直至的DFA的状态集中不产生新的状态(项目集)为止；
  5. 含有项目U → u. 的项目集,作为DFA的终态。  
   
例题：  
![LR(0)求CLOSURE问题.png](/storage/LR(0)求CLOSURE问题.png)  
答案：  
![LR(0)求CLOSURE答案.png](/storage/LR(0)求CLOSURE答案.png)  

#### 4.3.3 LR(0)分析表的构造
由识别活前缀的DFA构造LR(0)分析表的方法：
  1. 设状态i、j，若有GO(i，x)=j ，对于状态i中的项目A → α.xβ,
    * 若x ∈ VT，则置Action[i,x]=Sj
    * 若x ∈ VN，则置Action[i,x]=j
  2. 对于终态i中的项目A. ，若A 是G中第k个产生式，则对所有输入符号xVT(包括$), 均置Action[i,x]=rk ;
  3. 若终态i中含项目S’ → S. 则置Action[i,$]=acc ($表示输入串结束符);
  4. 其它情况均置错。

 
#### 4.3.4 LR(0)分析算法
1. 将输入串的左边界($)进符号栈和初始状态0进状态栈；  
2. 根据状态栈栈顶状态i和当前输入符号a查Action表进行如下工作:  
  * 移进:若Action[i，a]=Sj ，当前输入符号a进符号栈，并将输入符号所对应的新的状态j进状态栈，继续处理下一个输入符号；
  * 归约:若Action[i，a]=rj ，按指定产生式进行归约，假设产生式右部的符号串长度为n，则
    1) 符号栈栈顶的n个符号为句柄，所以符号栈栈顶n个符号出栈，同时，状态栈栈顶的n个元素也出栈；
    2) 归约后的文法符号A(非终结符)进符号栈；
    3) 假设当前状态栈栈顶为j，若Goto[j，A]=k，则将文法符号A所对应的新状态k进状态栈。
  * 接受:若动作表中对应“acc”，则分析成功；
  * 出错:若动作表中对应空白，则报告错误信息。
3. 重复以上2的工作直到接受或出错为止。

#### 4.3.5 项目的分类
* 移进项目：圆点之后为终结符的项目， A → α.aβ, α,β ∈ V*, a ∈ VT,它对应的状态为移进状态；例如S → aA.cBe
* 待约项目：圆点之后为非终结符的项目， A → α.Bβ ， α,β ∈ V*,B ∈ VN ,它对应的状态为待约状态；例如 S → aAc.Be
* 归约项目：圆点之后没有符号(圆点在最后)的项目，A → α. α ∈ V*,它对应的状态为归约状态；例如：S → aAcBe.
* 接受项目：对于拓广文法G[S’],有项目S’ → S.它是一个特殊的归约项目，称它为接受项目，它所对应的状态为接受状态。

#### 4.3.6LR(0)文法的定义

### 4.4 SLR(1) 分析
比LR(1)仅在发生冲突时向右边多看一个符号，构造分析表的规则不一样，算法步骤一致。  
分析表的构造：
  1. 设状态j是状态i输入符号x后到达的状态,即：   GO(i,x)=j     对于状态i中的项目A→α.xβ,若x∈VT，则置Action[i，x]=Sj，若x∈VN，则置Action[i，x]=j。
  2. 对于状态i中的归约项目：A→α.∈i  若A→α为文法的第j个产生式，则对于任意输入符号a,a∈Follow(A),则置Action[i,a]=rj。
  3. 若S→α.∈i,则置Action[i,$]=acc(S为开始符号)。
  4. 其他情况置错。

例题：  
![SLR(1)1.png](/storage/SLR(1).png)  
![SLR(1)2.png](/storage/SLR(2).png)   
答案：   
![SLR(1)3.png](/storage/SLR(3).png)  
![SLR(1)4.png](/storage/SLR(4).png)  
![SLR(1)5.png](/storage/SLR(5).png)    

### 4.5 一般的LR(1)
 LR(1)项目：在LR(0)项目中放置一个向右搜索符号a，成为LR(1)项目：[A → α.β ，a]。

### 4.6 LALR(1)分析
LR(1)分析比SLR(1)分析的能力有明显的提高，但是LR(1)也有缺点：分析表状态数过大，使分析的效率降低。为解决二者之间的能力与效率之间的矛盾，目前最流行的LALR(1)分析是最佳方案。
  
项目集通过同心集合并构造。
  * 同心集：LR(1)的两个项目集的LR(0)项目全部相同，则称两个LR(1)项目集具有相同的心，具有相同心的项目集称为同心集。 
  * 同心集合并：
      * 相同的心(LR(0)项目)不变；
      * 合并后项目集的搜索符等于合并前LR(1)项目搜索符的并集

### 4.7 语法分析器自动生成工具—YACC




## 5.语义分析（考点为5.1）
<span id="5"></span>
-------------------------------------------------------
### 5.1 属性和属性文法
* 属性文法是一个三元式： A=(G, V, F)
    * G是一个上下文无关文法；
    * V是一个属性的有限集合；
    * F是一个与属性有关的语义规则的有限集合。
* 合成属性
    ```Java
    //合成属性可以通过后序遍历分析树或语法树来计算
    void  PostEval (T: treenode);{ 
       for each child C of T do {
          PostEval (C);
          }
          compute all synthesized attributes of T;
      }

    ```
    ```Java
    //后序遍历计算十进制val属性
    void  postEval(SyntaxTree  t){
       int temp;
       if (t->kind = OpKind){ 
          postEval(t->lchild);
          postEval(t->rchild ) ;
          switch (t->op){ 
             case Plus:
             t->val=t->lchild->val + t->rchild->val;
             break ;
             case Minus:
             t->val=t->lchild->val - t->rchild->val;
             break ;
             case Mulop:
             t->val=t->lchild->val * t->rchild->val;
             break ;
             } 
         } 
      } 

    ```
* 继承属性
  ```Java
  //继承属性可以通过前序或前序中序结合的方式遍历分析树或语法树来计算
  void  PreEval(T: treenode){
     for each child C of T do
     compute all inherited attributes of C;
     PreEval ( C );
}
  ```Java
  //计算节点的dtype属性
  void EvalType(T: treenode) {
     case nodekind of  T of

     decl : 
     EvalType(firstchild of T );
     T.secondchild.dtype=T.firstchild .dtype;
     EvalType (secondchild of T );

     type : 
     if child of T = int
     T.dtype :=integer 
     else T.dtype := real;

     var-list:
     T.firstchild.dtype =T.dtype;
     if third child of T is not nil    
	   T.thirdchild.dtype =T.dtype;
	  	EvalType(third child of T );
     end case;
}
```
### 5.2 符号表
在编译程序工作过程中，需要收集、记录和使用源程序中一些语法符号的有关类型和特征等相关信息，会建立并保持一些表格，需要时进行查询或进一步扩展(添加)。常用表格有：变量名表、常数名表、数组名表、过程或子程序名表、保留字表等，统称为**符号表**或**名字表**或**属性表**。
* 符号表作用：收集有关标识符的属性、语法语义合法性检查的依据、目标代码生成阶段地址分配的依据
* 符号表的内容：名字、属性。属性包括名字的种类（常数变量数组函数）、类型（整型字符型实型布尔型）、出现特征、其他信息
* 符号表的操作：**增**：向表中填入一个新的名字；**删**：从表中删除一个或一组无用的项；**改**：对给定名字，在表中填写或更新它的某些信息；**查**：对给定的名字，判定此名字是否已在表中；**查**：对给定名字，访问它在表中的某些相关信息；

### 5.3 数据类型和类型检查
编译器的主要任务之一是数据类型信息的计算和维护(类型推论(type inference))以及使用这些信息确保程序的每一部分在语言的类型规则作用下有意义(类型检查(type checking))。

## 6.中间代码生成（考点为6.2-6.4）
<span id="6"></span>
--------------------------------------------------------
### 6.1 中间代码概览
中间代码，也称中间语言，是复杂性介于源程序和目标程序之间的一种机内表达形式，它是编译程序产生的中间临时结果。中间代码程序同源程序和目标程序的关系也同样是等价的，即结构不同，但语义相同。有三地址码和P-代码两种常见形式。  
* 优点： 
  * 使编译程序的算法清晰，便于分工、修改、维护和移植等；
  * 中间代码使编译器更容易重定向：不同机器上的编译器可以在已有前端的基础上附加一个适合这这台新机器的后端来生成；
  * 可以在中间代码上进行与机器无关的代码优化，优化过程实际上是对程序的操作过程，对程序进行操作必须首先把程序转换成其结构便于操作的数据，而中间代码正是为此设计的一种程序的数据结构表示。

### 6.2 基本的代码生成技术
#### 6.2.1 作为合成属性的中间代码或目标代码生成方法
计算代码生成的属性属于合成属性，可以在语法分析期间直接生成或者通过语法树的后序遍历生成。

#### 6.2.2 实际的代码生成方法
```Java
void genCode ( T: treenode ){ 
   if T is not nil ;
	//generate code to prepare for code of left child of T;
	genCode (left child of T ) ;
	//generate code to prepare for code of right child of T;
	genCode (right child of T ) ;
	generate code to implement the action of T;
}
```
* 中间代码生成的辅助函数：
  * **emit()**：函数emit() 将三地址语句输出到文件中；
  * **Newtemp()**：函数Newtemp()产生一个临时名字系列t1，t2，t3，…；
```Java
//简单算术表达式的三地址码生成过程的实现
Void genCode(SyntaxTree t){
   if(t!=NULL){
      switch(t -> kind){
         //先看节点类型
         case OpKind://如果是操作符
         switch(t -> op){
            //看是什么操作
            case Plus://加法
            genCode(t -> lchild);
            genCode(t -> rchild);temp=newtemp();
            emit(temp’=’ t -> lchild -> strval’+’t -> rchild -> strval)
            t -> strval=temp;
            break;
            
            case Assign://赋值
            genCode(t -> lchild);
            emit(t -> strval’=’ t -> lchild -> strval);
            t -> strval= t -> lchild -> strval; 
            break;
            
            default://报错
            emit(“error”);
            break;
    } 
    break;
    
    case ConstKind:
    break;
    
    case IdKind:
    break;
    
    default:
    emit(“error”);
    break;
    }
 }
}  
```

#### 6.2.3 从中间代码生成目标代码
自学内容，此处不做整理。


### 6.3 数据结构引用的代码生成
#### 6.3.1 地址计算

#### 6.3.2 数组引用的三地址码生成
C数组引用a[i]的地址是：
	 
    base_address(a) + i * sizeof(int)

```Java
//赋值语句：
t2 = a [t1]
//翻译成如下的三地址码：
t3 = t1 * elem_size (a)
t4 = &a + t3
t2 = *t4
```

```Java
//赋值语句： 
a[t2] = t1
//翻译成如下的三地址码：
t3 = t2 * elem_size(a)
t4 = &a + t3
*t4 = t1
```

#### 6.3.3 记录结构和指针引用
自学内容。

### 6.4 控制语句和逻辑表达式的代码生成
#### 6.4.1 if和while语句的代码生成
#### 6.4.2 逻辑表达式的代码生成（自学内容）
#### 6.4.3 if和while语句的代码生成过程举例


### 6.5 过程和函数调用的代码生成

## 7.运行时环境（考点为7.1和7.3）
<span id="7"></span>
--------------------------------------------------------



